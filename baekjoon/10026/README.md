# [백준 10026 - 적록색약](https://www.acmicpc.net/problem/10026)

- [문제분석](#문제분석)
    * [요구사항](#요구사항)
    * [조건](#조건)
    * [제한사항](#제한사항)
- [접근방법](#접근방법)
- [의사코드](#의사코드)
- [코드분석](#코드분석)
    * [시간복잡도](#시간복잡도)
    * [리펙토링](#리펙토링)

## 문제분석

### 요구사항

⭐️ 적록색약이 아닌 사람이 봤을 때의 <U>**구역의 개수**</U>와   
적록색약인 사람이 봤을 때의 <U>**구역의 수**</U>를
공백으로 구분해 출력한다.

### 조건

* 같은 색상이 `상하좌우로 인접`해 있는 경우에 두 글자는 같은 구역에 속한다.

* 첫째 줄에 그림의 크기 `N`이 주어지고,

* 둘째 줄부터 N개 줄에 그림이 주어진다.

> 입력예시
> ```shell
> 5
> RRRBB
> GGBBB
> BBBRR
> BBRRR
> RRRRR
> ```

### 제한사항

* `1 ≤ N ≤ 100`
* 시간제한 : `1초`
* 메모리 제한 : `128MB`

## 접근방법

* `DFS`로 탐색하면서 <U>**방문한 좌표에 숫자를 매긴다**</U>.  
* 이때 색을 구분하여 최초 좌표의 색과 동일한 경우에만 탐색한다.  
* 색약인 경우에는 `적색`(`R`)과 `녹색`(`G`)을 같은 색으로 취급한다.

## 의사코드

```c++
vector<pair<int, int>> loops = {{1,  0}, {0,  1}, {-1, 0}, {0,  -1}};

void dfs(int i, int j, int k) {
    for (상하좌우 좌표 배열) {
        int x = 다음 x 좌표
        int y = 다음 y 좌표
        if (다음 좌표 색이 있는 경우 && 방문하지 않은 경우 && 다음 좌표가 현재 좌표와 색이 같은 경우) {
            visited[x][y] = k;
            dfs({x, y}, k);
        }
    }
}
```

## 코드분석

### 시간복잡도

* 입력 : 그림의 크기 N
* 연산 : 다음 좌표가 유망한지 검사하는 비교연산
  * 각 좌표마다 `4`번의 연산을 시행하므로 `4 * N` = `O(4N)`이다.
  * 그림의 최대 크기는 `100 * 100`이므로 최악의 경우 `40000`번의 연산이 시행된다. 
