# [백준 1080 - 행렬](https://www.acmicpc.net/problem/1080)

- [백준 1080 - 행렬](#백준-1080---행렬)
	- [문제분석](#문제분석)
		- [요구사항](#요구사항)
		- [조건](#조건)
			- [입력](#입력)
			- [출력](#출력)
		- [제한사항](#제한사항)
	- [접근방법](#접근방법)
		- [선택 절차](#선택-절차)
		- [적절성 검사](#적절성-검사)
		- [해답 검사](#해답-검사)
	- [의사코드](#의사코드)
	- [코드분석](#코드분석)
		- [예외처리](#예외처리)

## 문제분석

### 요구사항

⭐️ `행렬 A`를 `행렬 B`로 바꾸는데 필요한 연산의 횟수의 `최솟값`

### 조건

* `N`과 `M`은 `50`보다 작거나 같은 `자연수`

#### 입력

* 첫째 줄에 행렬의 크기 `N` `M`이 주어진다.
* 둘째 줄부터 `N개의 줄`에는 `행렬 A`가 주어지고,
* 그 다음줄부터 `N개의 줄`에는 `행렬 B`가 주어진다.

#### 출력

### 제한사항
|시간 제한|메모리 제한|
|:---:|:---:|
|`2` 초|`128` MB|

## 접근방법

그리디 알고리즘은 현재 상황에서 최적의 선택을 하는 것하는 것이다.

### 선택 절차

생각해 볼 수 있는 최적의 선택은 다음과 같다.
1. 한 번에 많은 부분을 뒤집는다.
2. 중복을 최소화하여 뒤집는다.

문제에서 요구하는 결과는 뒤집는 연산을 최소로 하는 것이다. 한 번에 많은 부분을 뒤집었더라도, 한 개라도 다른 것이 있으면 다시 뒤집어야 하기 때문에 최적의 해라고 볼 수 없다. 따라서 <U>**중복을 최소화**</U>하면서 뒤집는 연산을 실행해야한다.

### 적절성 검사

중복을 최소화하기 위해서는 뒤집어서 같아진 부분이 다시 뒤집히는 일이 없도록 해야한다.

따라서 <U>**좌상단 부터 순서대로 순회**</U>하여 뒤집으면 이미 순회한 부분은 더 이상 뒤집히지 않을 것이므로, 중복하여 뒤집는 연산을 최소화하게 된다.

### 해답 검사

모든 선택이 완료되면 `행렬 A`와 `B`가 같은지 확인해야한다.

## 의사코드

```c++
int greedy() {
	int answer = 0;
	for (int i = 0; i < n - 3 + 1; ++i) {
		for (int j = 0; j < m - 3 + 1; ++j) {
			if (a[i][j] != b[i][j]) {
				answer++;
				filp(i, j);
			}
		}
	}
	return (0);
}
```

## 코드분석

### 예외처리

* `해가 없는 경우`에는 `-1`을 출력해야한다.

* 행렬이 `3x3 미만`인 경우에는 뒤집는 연산을 수행할 수 없으므로, `행렬 A`와 `B`가 다르면 `-1`, 같으면 `0`을 출력해야한다.