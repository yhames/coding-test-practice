# [백준 19644 - 좀비 떼가 기관총 진지에도 오다니](https://www.acmicpc.net/problem/19644)

- [문제분석](#문제분석)
    * [요구사항](#요구사항)
    * [조건](#조건)
    * [제한사항](#제한사항)
- [접근방법](#접근방법)
- [의사코드](#의사코드)
- [코드분석](#코드분석)
    * [시간복잡도](#시간복잡도)
        * [누적 합](#누적-합)
        * [슬라이딩 윈도우](#슬라이딩-윈도우)
    * [리펙토링](#리펙토링)
      * [using](#using)

## 문제분석

### 요구사항

⭐️킬로와 헥토가 살아남을 수 있다면 `YES`, 살아남을 수 없다면 `NO`를 출력

> `1`m 떨어진 길 위의 좀비를 제압하지 못한다면 사망

### 조건

**입력**
* `L` : 기관총 진지 앞쪽 길의 거리
* `M_L` : 기관총의 유효 사거리
* `M_K` : 기관총의 살상력
* `C` : 수평 세열 지향성 지뢰의 개수
* `Z_i` : 좀비의 체력, `i`는 `i`m 떨어져 있다는 것을 의미

**출력**
```shell
YES
```
```shell
NO
```

### 제한사항

* `L` : `1 ≤ L ≤ 3 * 10^6`
* `M_L` : `1 ≤ M_L ≤ 3 * 10^6`
* `M_K` : `1 ≤ M_K ≤ 100`
* `C` : `0 ≤ C ≤ 3 * 10^6`
* `Z_i` : `0 ≤ Z_i ≤ 3 × 10^8`

> `L` 값이 최대 `3,000,000` 이므로 `O(N^2)`이면 `9,000,000,000,000` 번 연산이 된다.

## 접근방법

`좀비의 체력`과 `누적데미지`를 나타내는 `pair<int, int>` 자료형을 선언하여 `리스트`에 담는다.

`리스트`를 순회하면서 `누적데미지`보다 `체력`이 더 높으면 `지뢰`(`c`)를 사용한다.

`지뢰`(`c`)를 사용하면 그 뒤에 `사거리`(`m_l`)까지 `살상력`(`m_k`)만큼 `누적데미지`를 감소시킨다. 

## 의사코드
```C++
int main() {
	while (리스트에 좀비가 없을 때 까지 반복) {
		if (누적 데미지 >= 좀비의 체력)
			맨 앞의 좀비 제거
		else if (지뢰가 있으면) {
			맨 앞의 좀비 제거
			지뢰 개수 - 1
			for (지뢰를 사용한 지점부터 m_l까지)
				누적데미지에서 m_k만큼 감소  
		} else {
			제거할 수 없으므로 NO 출력
			return (0);
		}
	}
	모든 좀비를 제거했으므로 YES 출력
	return (0);
}
```

## 코드분석

아무리 `시간복잡도`를 줄여도 `시간초과`가 난다.

### 시간복잡도

* 입력 : 좀비의 수 `N`, 지뢰의 개수 `C`
* 연산 : 최악의 경우 `O(N^2)`
  * 마지막 좀비까지 앞으로 전진하면서 제거해야하므로 `N`번 순회
  * 지뢰를 사용하는 경우 `m_l`번 만큼 순회하므로 `C * M_L`번 순회
  * 지뢰의 개수 또한 최대 `3,000,000`이므로 `N`과 같다.
  * 따라서 최악의 경우 `O(N*C) = O(N^2)`가 된다.

`지뢰`의 개수 `C`의 제한조건을 제대로 확인하지 않아서 최대 개수가 적을 것이라고 생각했다.

24번 도전 끝에 결국 하단의 알고리즘 분류를 보고 `누적 합`에 대한 개념공부를 하고 문제풀이를 다시 진행했다.

#### 누적 합

`누적 합` : 배열의 특정 범위에 대한 부분 합을 구하는 알고리즘

자세한 내용은 [PDF 참고](URL)

#### 슬라이딩 윈도우

슬라이딩 윈도우 : // todo

자세한 내용은 [PDF 참고](URL)

### 리펙토링

#### using

// todo
