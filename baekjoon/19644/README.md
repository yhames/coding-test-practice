# [백준 19644 - 좀비 떼가 기관총 진지에도 오다니](https://www.acmicpc.net/problem/19644)

- [문제분석](#문제분석)
    * [요구사항](#요구사항)
    * [조건](#조건)
    * [제한사항](#제한사항)
- [접근방법](#접근방법)
- [의사코드](#의사코드)
- [코드분석](#코드분석)
    * [시간복잡도](#시간복잡도)
        * [누적 합과 슬라이딩 윈도우](#누적-합과-슬라이딩-윈도우)
    * [리펙토링](#리펙토링)
      * [using](#using)

## 문제분석

### 요구사항

⭐️킬로와 헥토가 살아남을 수 있다면 `YES`, 살아남을 수 없다면 `NO`를 출력

> `1`m 떨어진 길 위의 좀비를 제압하지 못한다면 사망

### 조건

**입력**
* `L` : 기관총 진지 앞쪽 길의 거리
* `M_L` : 기관총의 유효 사거리
* `M_K` : 기관총의 살상력
* `C` : 수평 세열 지향성 지뢰의 개수
* `Z_i` : 좀비의 체력, `i`는 `i`m 떨어져 있다는 것을 의미

**출력**
```shell
YES
```
```shell
NO
```

### 제한사항

* `L` : `1 ≤ L ≤ 3 * 10^6`
* `M_L` : `1 ≤ M_L ≤ 3 * 10^6`
* `M_K` : `1 ≤ M_K ≤ 100`
* `C` : `0 ≤ C ≤ 3 * 10^6`
* `Z_i` : `0 ≤ Z_i ≤ 3 × 10^8`

> `L` 값이 최대 `3,000,000` 이므로 `O(N^2)`이면 `9,000,000,000,000` 번 연산이 된다.

## 접근방법

`좀비의 체력`과 `누적데미지`를 나타내는 `pair<int, int>` 자료형을 선언하여 `리스트`에 담는다.

`리스트`를 순회하면서 `누적데미지`보다 `체력`이 더 높으면 `지뢰`(`c`)를 사용한다.

`지뢰`(`c`)를 사용하면 그 뒤에 `사거리`(`m_l`)까지 `살상력`(`m_k`)만큼 `누적데미지`를 감소시킨다. 

## 의사코드
```C++
int main() {
	while (리스트에 좀비가 없을 때 까지 반복) {
		if (누적 데미지 >= 좀비의 체력)
			맨 앞의 좀비 제거
		else if (지뢰가 있으면) {
			맨 앞의 좀비 제거
			지뢰 개수 - 1
			for (지뢰를 사용한 지점부터 m_l까지)
				누적데미지에서 m_k만큼 감소  
		} else {
			좀비를 제거할 수 없으므로 NO 출력
			return (0);
		}
	}
	모든 좀비를 제거했으므로 YES 출력
	return (0);
}
```

## 코드분석

아무리 `시간복잡도`를 줄여도 `시간초과`가 난다.

### 시간복잡도

* 입력 : 좀비의 수 `N`, 지뢰의 개수 `C`
* 연산 : 최악의 경우 `O(N^2)`
  * 마지막 좀비까지 앞으로 전진하면서 제거해야하므로 `N`번 순회
  * 지뢰를 사용하는 경우 `m_l`번 만큼 순회하므로 `C * M_L`번 순회
  * 지뢰의 개수 또한 최대 `3,000,000`이므로 `N`과 같다.
  * 따라서 최악의 경우 `O(N*C) = O(N^2)`가 된다.

`지뢰`의 개수 `C`의 제한조건을 제대로 확인하지 않아서 최대 개수가 적을 것이라고 생각했다.

24번 도전 끝에 결국 하단의 알고리즘 분류를 보고 `누적 합`에 대한 개념공부를 하고 문제풀이를 다시 진행했다.

#### 누적 합과 슬라이딩 윈도우

`누적 합` : 배열의 특정 **범위**에 대한 부분 합을 구하는 알고리즘

`슬라이딩 윈도우` : 배열의 특정 **구간**에 대한 부분 합을 구하는 알고리즘  
`누적 합`과 동일하지만 부분 합을 구하는 <U>**범위가 고정**</U>되어있다는 차이가 있다.

자세한 내용은 [PDF 참고](URL)

### 리펙토링

#### using

`C++11` 이후 `모던 C++`에는 `using`이라는 문법이 추가되었다.

`using`은 `typedef`와 동일하게 별칭을 지정하는 명령어로 기능상 동일하지만 `using`은 `template`을 지원한다는 차이가 있다.

`pair<int, int>`는 변수의 의미가 명확하지 않으므로 `구조체`를 선언하여 사용하거나 간단한게 `using`을 사용하여 이름을 지정하여 가독성을 높일 수 있다.

```c++
struct zombie
{
	int hp;
	int damaged;
};
```

```c++
using pair<int, int> = zombie;
```

#### 리펙토링 코드

```c++

list<int> damaged;  // 누적 데미지 리스트

int main() {
	// 구간(윈도우) 리스트 초기화
	for (ml만큼 반복) {
		cin >> zombie;
        if (누적 데미지 <= 좀비의 체력) {
		    이전 데미지에서 누적 데미지를 더하고, 리스트의 마지막에 추가
		} else if (지뢰가 있으면) {
            지뢰 개수 - 1
            이전 데미지에서 누적하지 않고, 리스트 마지막에 추가
		} else {
            좀비를 제거할 수 없으므로 NO 출력
            return (0);
		}
	}
	
	// 구간(윈도우)을 옮기면서 좀비를 제거할 수 있는지 확인
	for (ml부터 l까지 반복) {
		cin >> zombie;
		damage = 직전 좀비까지의 누적데미지 
		damaged의 맨 앞 노드 삭제
		if (좀비의 체력 <= 직전 좀비까지의 누적데미지 + 기관총 살상력) {
		    이전 데미지에서 누적 데미지를 더하고, 리스트의 마지막에 추가
		} else if (지뢰가 있으면) {
		    지뢰 개수 - 1
            이전 데미지에서 누적하지 않고, 리스트 마지막에 추가
		} else {
            좀비를 제거할 수 없으므로 NO 출력
			return (0);
		}
	}
	모든 좀비를 제거했으므로 YES 출력
	return (0);
}
```