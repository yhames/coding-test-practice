# [백준 1992 - 쿼드트리](https://www.acmicpc.net/problem/1992)

- [백준 1992 - 쿼드트리](#백준-1992---쿼드트리)
  - [문제분석](#문제분석)
    - [요구사항](#요구사항)
    - [조건](#조건)
    - [제한사항](#제한사항)
  - [접근방법](#접근방법)
  - [의사코드](#의사코드)
  - [코드분석](#코드분석)
    - [시간복잡도](#시간복잡도)
    - [메모리 복잡도](#메모리-복잡도)

## 문제분석

### 요구사항

⭐️ `N×N` 크기의 영상이 주어질 때, 이 영상을 `쿼드트리`로 압축한 결과를 출력

### 조건

`쿼드트리`는 `왼쪽 위`, `오른쪽 위`, `왼쪽 아래`, `오른쪽 아래`로 영상을 나누어 압축한하고, 이 4개의 영역을 압축한 결과를 `차례대로 괄호 안에 묶어서 표현`한다.

> → 각 영역의 `순서`가 중요하다.

### 제한사항

시간 제한 : `2초`

메모리 제한 : `128MB`

영상의 크기 `N` : `1 ≤ N ≤ 64`

영상은 `N`개의 문자열로 입력되며, 각 문자열은 `0 또는 1`로 구성된다.

영상의 크기는 항상 `NxN`의 형태로 주어진다.

## 접근방법

영상을 더 이상 나누어질 수 없는 단위(`1x1`)까지 분할하여 압축 결과값을 저장한다.  
예를 들어 `8x8`은 `4x4`가 `4`개 이며, `4x4`는 `1x1`이 `4`개인 영상이므로, 분할된 부분배열의 결과값을 병합하여 정답을 도출한다.

## 의사코드

```c++
void divide(int x, int y, int size) {
    int checksum = 부분배열의 총합;
    for (int i = x; i < x + size; ++i) {
        for (int j = y; j < y + size; ++j) {
            현재 부분배열의 값을 모두 더한다.
        }
    }
    if (checksum == size * size) {
        모두 1인 경우 "1" 출력
    } else if (checksum == 0) {
        모두 0인 경우 "0" 출력
    } else {    // 0과 1이 섞여있는 경우
        answer.append("(");
        divide(x, y, size / 2);             // 왼쪽 위
        divide(x, y + size / 2, size / 2);  // 오른쪽 위
        divide(x + size / 2, y, size / 2);  // 왼쪽 아래
        divide(x + size / 2, y + size / 2, size / 2);   // 오른쪽 아래
        answer.append(")");
    }
}
```

## 코드분석

### 시간복잡도

* 입력 : 영상의 크기 `N`
* 연산 : 부분배열 검사하는 더하기 연산
  * 최악의 경우 부분배열의 `depth`만큼 `N^2`만큼의 연산을 반복해야하므로 `O(((logN)-1) * N^2)`이다.
  * 하지만, `N`의 제한조건이 `64`이므로 최대 `5 * 64^2 = 32768`번의 덧셈 연산을 수행한다.

### 메모리 복잡도

각 부분 배열이 함수로 호출되어 결과값을 가져오기때문에 최소 `4096`번 호출된다.  
하지만 `N`의 최대값이 `64`이기 때문에 최대 `depth`가 `6`이므로 메모리 사용량은 크지 않을 것으로 예상된다.


