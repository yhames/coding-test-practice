# [백준 2263 - 트리의 순회](https://www.acmicpc.net/problem/2263)

- [백준 2263 - 트리의 순회](#백준-2263---트리의-순회)
  - [문제분석](#문제분석)
    - [요구사항](#요구사항)
    - [조건](#조건)
    - [제한사항](#제한사항)
  - [접근방법](#접근방법)
  - [의사코드](#의사코드)
  - [코드분석](#코드분석)
    - [트리 순회 알고리즘](#트리-순회-알고리즘)
      - [전위 순회(Pre-Order)](#전위-순회pre-order)
      - [중위 순회(In-Order)](#중위-순회in-order)
      - [후위 순회(Post-Order)](#후위-순회post-order)
    - [시간복잡도](#시간복잡도)
    - [리펙토링](#리펙토링)


## 문제분석

### 요구사항

⭐️ 이진트리의 `프리오더`를 구하는 프로그램을 작성

### 조건

동일한 이진트리의 `인오더`와 `포스트오더`가 주어진다.

### 제한사항

* 시간 제한 : `5초`
* 메모리 제한 : `128MB`

> 시간 제한이 5초이기 때문에, 시간복잡도는 여유롭지만, 메모리 제한이 128MB이므로 재귀함수 호출 등 메모리 관리를 신경써야한다.

## 접근방법

`중위 순회`와 `후위 순회`의 각 특성에 따른 힌트를 사용한다.

* 중위 순회 : root를 기준으로 left와 right 서브트리를 나눌 수 있다.
* 후위 순회 : root가 배열의 맨 마지막에 위치한다.

위 2가지 힌트를 이용하여 `root`를 찾아 저장한다.

이 떄 `전위 순회`는 `왼쪽 root 부터 탐색`하기 때문에
재귀 반복시 `왼쪽부터 호출`한다.

## 의사코드

```C++
/**
  * i_start : 중위순회 서브트리의 시작 인덱스
  * i_end   : 중위순회 서브트리의 마지막 인덱스
  * p_start : 후위순회 서브트리의 시작 인덱스
  * p_end   : 후위순회 서브트리의 마지막 인덱스
  * i_root  : 중위순회 서브트리의 root 원소 인덱스
  */
void divide(int i_start, int i_end, int p_start, int p_end) {
    전위순회.push_back(후위순회 서브트리의 마지막 원소);
    for (int i = i_start; i <= i_end; ++i) {
        if (중위순회 서브트리에서 root를 찾으면) {
            i_root = i;
            break;
        }
    }
    divide(왼쪽 서브트리);
    divide(오른쪽 서브트리);
}
```

## 코드분석

### 트리 순회 알고리즘

* 전위 순회 : `root` → `left` → `right`
* 중위 순회 : `left` → `root` → `right`
* 후위 순회 : `left` → `right` → `root`

#### 전위 순회(Pre-Order)

#### 중위 순회(In-Order)

#### 후위 순회(Post-Order)

### 시간복잡도

### 리펙토링
