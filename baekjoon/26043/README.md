# [백준 26043 - 식당 메뉴](https://www.acmicpc.net/problem/26043)

- [문제분석](#문제분석)
    * [요구사항](#요구사항)
    * [조건](#조건)
    * [제한사항](#제한사항)
- [접근방법](#접근방법)
- [의사코드](#의사코드)
- [코드분석](#코드분석)
    * [시간복잡도](#시간복잡도)
    * [리펙토링](#리펙토링)
      * [Pair와 Tuple](#pair와-tuple)
      * [emplace()](#emplace)

## 문제분석

### 요구사항

다음을 출력하시오.
* 본인이 좋아하는 메뉴를 먹은 학생 목록 `A`
* 본인이 좋아하지 않는 메뉴를 먹은 학생 목록 `B`
* 학교 식당에 도착하였으나 식사를 하지 못한 학생 목록 `C`

⭐️ **각 목록은 오름차순으로 정렬되어야한다.** 

> 첫 번째 줄에 학생 목록 A에 있는 학생 번호를 빈칸을 사이에 두고 오름차순으로 출력한다.  
> 두 번째 줄에 학생 목록 B에 있는 학생 번호를 빈칸을 사이에 두고 오름차순으로 출력한다.  
> 세 번째 줄에 학생 목록 C에 있는 학생 번호를 빈칸을 사이에 두고 오름차순으로 출력한다.  
> 학생 목록에 학생이 없는 경우 학생 번호 대신 None을 출력한다.  

> 출력 예시
> ```shell
> 2 3
> 1
> None
> ```

### 조건

입력값
* `n` : `S`에 저장된 정보의 개수
* `S` : 식당에 도착한 정보(`유형1`)와 제공된 식사 정보(`유형2`)
  * 유형 1 : 유형번호 학생번호 메뉴번호 `1 2 1`
  * 유형 2 : 유형번호 메뉴번호 ex) `2 1`

> 입력 예시
> ```shell
> 6
> 1 2 1   # 유형 1 학생번호 2 메뉴번호 1
> 1 1 1
> 2 1     # 유형 2 메뉴번호 1
> 1 3 2
> 2 2
> 2 2
> ```

### 제한사항

* `1 ≤ n ≤ 500,000`
* `S`에는 유형 `1`, 유형 `2`만 저장
* `1 ≤ a ≤ n`, 모든 학생번호(`a`)의 값은 서로 다르다.
* 메뉴(`b`)는 1 또는 2이다.

## 접근방법

`Queue`를 사용하여 식당에 들어오고 나가는 것을 구현.  
`Student` 클래스를 생성하여 `Queue`에 객체 저장.  
출력 목록을 서로 다른 `Vector`에 저장하여 출력.  

## 의사코드
```C++
int main() {
    queue<Student> queue;
    vector<int> list_a;
    vector<int> list_b;
    vector<int> list_c;
    
    cin >> n;
    for (n 만큼 반복) {
        cin >> 유형
        if (유형 1인 경우) {
            cin >> 학생번호 >> 메뉴번호;
            queue.push(Student(학생번호, 메뉴번호));
        }
        else if (유형 2인 경우) {
            cin >> 메뉴번호
            if (맨 앞의 학생이 원하는 메뉴와 제공되는 메뉴가 같은 경우)
                type_a.push_back(학생번호);
            else if (맨 앞의 학생이 원하는 메뉴와 제공되는 메뉴가 다른 경우)
                type_b.push_back(학생번호);
            queue.pop();
        }
    }
    while (아직 학생이 남아있는 경우) {
        type_b.push_back(학생번호);
        queue.pop();
    }
    오름차순으로_출력(type_a);
    오름차순으로_출력(type_b);
    오름차순으로_출력(type_c);
}
```

### 리펙토링

#### Pair와 Tuple

`pair`(2쌍)혹은 `tuple`(3쌍)을 사용하면 불필요하게 클래스를 생성할 필요가 없다.
* 헤더파일
  * `pair` : `utiliy.h`
  * `tuple` : `tuple.h`

* 형태
  * `template <class T1, class T2> struct pair;`
  * `template< class... Types > class tuple;`

* 사용방법
  * `pair<T, T> p1`
    * `pair.front`, `pair.second`으로 해당 값을 참조할 수 있다. 
    * `get<0>(p1)`, `get<1>(p2)` 와 같이 사용할 수도 있다.
  * `tuple<T ...> t1`
    * `get<0>(t1)`, `get<1>(t1), ...`으로 해당 값을 참조할 수 있다.

#### emplace()

`push()` 대신 `emplace()`를 사용하면
간단하게 인자만 전달하여 내부에서 객체를 생성하여 추가할 수 있다.

```C++
// stand.push(pair<int, int>(id, desired));
stand.emplace(id, desired);
```