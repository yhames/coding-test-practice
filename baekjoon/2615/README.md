# [백준 2615 - 오목](https://www.acmicpc.net/problem/2615)

- [백준 2615 - 오목](#백준-2615---오목)
  - [문제분석](#문제분석)
    - [요구사항](#요구사항)
    - [조건](#조건)
      - [입력](#입력)
      - [출력](#출력)
    - [제한사항](#제한사항)
  - [접근방법](#접근방법)
  - [의사코드](#의사코드)
  - [코드분석](#코드분석)

## 문제분석

### 요구사항

⭐️ 검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성

### 조건

#### 입력
입력값 : `19줄`에 각 줄마다 `19개의 숫자`로 표현
* 검은 바둑알은 `1`
* 흰 바둑알은 `2`
* 알이 놓이지 않는 자리는 `0`

> 입력예시
```shell
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 0 0 2 2 2 1 0 0 0 0 0 0 0 0 0 0
0 0 1 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

#### 출력

* `첫줄`에 `검은색`이 이겼을 경우에는 `1`, `흰색`이 이겼을 경우에는 `2`, 아직 승부가 결정되지 않았을 경우에는 `0`을 출력
* 여섯 알 이상 연속으로 놓인 경우에는 이긴 것이 아님
* 검은색 또는 흰색이 이겼을 경우에는 둘째 줄에 연속된 다섯 개의 바둑알 중에서 `가장 왼쪽`에 있는 바둑알(세로로 놓인 경우 가장 위에 있는 것)의 `가로줄 번호`와, `세로줄 번호`를 순서대로 출력

> 출력예시
```shell
1
3 2
```

### 제한사항

|시간 제한|메모리 제한|
|:---:|:---:|
|`1` 초|`128` MB|

## 접근방법

오목판을 2차원배열로 입력받는다.

`(0, 0)`부터 `(19, 19)`까지 순서대로 순회하여 오목을 찾는다.

모든 방향을 탐색하여 오목이 있는지 확인한다.

정답은 좌상단의 좌표를 출력한다.

> ⭐️ 육목은 안된다.

## 의사코드

```c++
bool dfs() {
    if (depth == 5) {
        if (다음 돌이 같은 색이면)
            return (false);
        가장 왼쪽 상단에 있는 좌표를 answer에 할당한다;
        return (true);
    }
    if (현재 돌이 이전 돌과 같으면)
        dfs로 계속 탐색 ? true : false;
}

bool is_ohmok() {
    for (8방향 모두 검사한다.) {
        if (다음 방향에 같은 색의 돌이 있고
            && 반대 방향에 같은 색의 돌이 없으면)  // 육목 방지
            dfs로 해당 방향을 탐색 ? true : false;
    }
    return (false);
}

int main() {
    for (int i = 1; i <= 19; ++i) {
        for (int j = 1; j <= 19; ++j) {
            if (돌이 있고 && is_ohmok이면)
                정답 출력;
        }
    }
    오목이 없으면 0을 출력;
    return (0);
}
```

## 코드분석

`8 방향`을 모두 탐색하면 매번 좌상단을 찾아야하기 때문에 전역변수 `answer`를 선언하여 계속 비교해야한다.

반면 현재 좌표에서 `우상↗`,  `우→`, `우하↘`, `하↓` 방향으로 탐색을 하면 탐색의 시작 지점이 항상 좌상단이 된다.  

```
OO↗  
OO→  
O↓↘
```
