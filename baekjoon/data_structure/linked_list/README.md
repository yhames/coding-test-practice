# 연결리스트

* [리스트와 연결리스트](#리스트와-연결리스트)
* [배열의 한계](#배열의-한계)
* [동적배열과 연결리스트](#동적배열과-연결리스트)
  * [메모리 참조, 삽입, 삭제](#메모리-참조-삽입-삭제)
  * [메모리 효율성](#메모리-효율성)
  * [캐시 효율성](#캐시-효율성)
* [정리 및 결론](#정리-및-결론)
* [추가 : C++ STL(Standard Template Library)](#추가--c-stlstandard-template-library)

## 리스트와 연결리스트

리스트 : 스택, 큐 등과 같이 데이터를 저장하는 방법, 즉 `자료구조`를 의미한다.

선형 리스트 : 데이터가 `순서 혹은 위치`를 가지고 `연속적`으로 이어져있는 구조를 의미한다.

연결리스트 : 배열, 동적배열과 같이 자료구조를 `구현`하는 프로그래밍 기법이다.
스택, 큐 등 선형 자료구조를 구현하기위해 사용한다.

## 배열의 한계

배열은 크기가 고정되어있다는 한계가 있다.
물론 `#define`이나 매개변수를 사용하여 배열의 크기를 할당할 수 있지만
권장되는 방법은 아니다.
> 매크로를 사용하는 방법은 컴파일 단계에서 -D 옵션을 통해 설정할 수 있지만
런타임에서 동적으로 할당되는 것이 아니기 때문에 가변길이 배열이라고 할 수 없다.  
> 또한 매개변수를 받아서 배열의 크기를 지정하는 방법은 어떤 값이 들어올지 모르기 때문에
StackOverflow 등 여러가지 문제가 발생할 수 있으므로 적절하지 않다.

따라서 동적으로 배열의 크기를 설정하기 위해서 `동적배열` 혹은 `연결리스트` 같은 자료구조를 사용한다.  
`C++`에서는 `동적배열`과 `연결 리스트`를 각각 `vector`와 `list`로 제공하고 있다.

## 동적배열과 연결리스트

### 동적배열
동적배열은 초기에 `여유 공간`을 할당하고,  
공간이 부족하면 `더 큰 공간`을 할당하여 `값을 복사`하여 사용한다.
* 시간복잡도
  * 참조 : 배열의 참조연산은 물리적 주소에 직접 접근하기 때문에 항상 `O(1)`이다.
  * 삽입 : 배열의 삽입연산은 상황과 위치에 따라 다르다.
    * 공간 O, 맨 뒤 : `O(1)`
    * 공간 O, 맨 앞 혹은 중간 : `O(N)` 
    * 공간 X, 맨 뒤 : `O(N)`
    * 공간 X, 맨 앞 혹은 중간 : `O(N)`
  * 삭제 : 삭제 연산도 삽입연산과 마찬가지로 위치에 따라 다른다.
    * 맨 앞 혹은 중간 : `O(N)`
    * 맨 뒤 : `O(1)`

### 연결리스트
이에 반해 연결리스트는 각각 독립된 `노드`라는 구조체를 사용하며,
해당 노드 안에 `값`과 `다음 노드의 주소`를 갖는다.
* 시간복잡도
  * 참조 :
    * 연결리스트는 참조시 항상 맨 앞 노드부터 차례로 확인해야하므로 `O(N)`이 걸린다.
  * 삽입/삭제 :
    * 삽입/삭제 연산만 본다면 `O(1)`이지만
    * 이를 위해 반드시 `O(N)`의 참조연산이 선행되어야 한다.

### 메모리 참조, 삽입, 삭제

동적배열과 연결리스트의 참조, 삽입, 삭제 연산의 구체적인 동작 방식은 [PDF](https://github.com/yhames/coding-test-practice/blob/main/baekjoon/data_structure/linked_list/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8.pdf)
를 참고하거나 [VisuAlgo](https://visualgo.net/en/list)를 참고한다.

### 메모리 효율성

연결리스트는 배열과 다르게 항상 다음 노드의 주소를 가지고 있어야한다.
```c++
struct Linked_List{
	int value;
	char *name[20];
	struct Linked_List *next;   // 다음 노드의 주소
};
```
여기서 노드의 주소값은 `8바이트`이므로 각 노드의 `value`가 충분히 큰 값이라면 미미하겠지만,    
`value`가 `int` 자료형 하나라면 배열에 비해 더 많은 메모리를 추가로 사용해야한다.

```c++
struct Linked_List{
	int value;      // 4바이트
	struct Linked_List *next;   // 8바이트
};
```
입력 데이터가 100개인 경우  
* 배열 : `4 * 100` = `400byte`  
* 연결리스트 : `(4 + 8) * 100` = `1200byte`
  * → 실제로는 노드 하나에 16 바이트가 되어서 최종적으로 1600byte가 된다.

### 캐시 효율성

`CPU`는 `메모리(RAM)`에 접근하기 전에 `캐시 메모리`에 데이터가 있는지 확인한다.  
이때 `Cache Hit Rate`이란 요청한 데이터를 캐시 메모리에서 찾을 확률이다.  
`캐시 메모리`는 `지역성(Locality)` 개념에 근거하여 데이터를 저장한다.  
  * `시간 지역성`(Time Locality) : `최근에` 참조한 데이터는 다시 참조될 확률이 높다.
  * `공간 지역성`(Space Locality) : 참조된 데이터와 `인접한` 데이터는 참조될 확률이 높다.

<U>물리적으로 연속적인 메모리</U>에 데이터를 저장하는 `배열`과 달리  
`연결리스트`는 <U>비연속적인 메모리</U>에 저장하기 때문에 캐시 효율성이 떨어진다.    
따라서 리스트의 요소를 순회할 때 물리적으로 연속적인 배열에 비해 메모리 최적화가 안되는 <U>**연결 리스트가 더 느리다**</U>.

## 정리 및 결론

<U>**반복 중에**</U> 삽입/삭제 연산을 해야한다면 `연결리스트`!

그 외에는 `동적배열`을 활용!

## 추가 : C++ STL(Standard Template Library)

`C++`에서 `list`와 `vector`의 사용방법은 [모두의 코드 C++ 강의](https://modoocode.com/223)를 참고했다. 

